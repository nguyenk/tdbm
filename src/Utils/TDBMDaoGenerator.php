<?php
declare(strict_types=1);

namespace TheCodingMachine\TDBM\Utils;

use Doctrine\Common\Inflector\Inflector;
use Doctrine\DBAL\Schema\Schema;
use Doctrine\DBAL\Schema\Table;
use Doctrine\DBAL\Types\Type;
use TheCodingMachine\TDBM\ConfigurationInterface;
use TheCodingMachine\TDBM\TDBMException;
use TheCodingMachine\TDBM\TDBMSchemaAnalyzer;
use Symfony\Component\EventDispatcher\EventDispatcherInterface;
use Symfony\Component\Filesystem\Filesystem;

/**
 * This class generates automatically DAOs and Beans for TDBM.
 */
class TDBMDaoGenerator
{
    /**
     * @var Schema
     */
    private $schema;

    /**
     * Name of composer file.
     *
     * @var string
     */
    private $composerFile;

    /**
     * @var TDBMSchemaAnalyzer
     */
    private $tdbmSchemaAnalyzer;

    /**
     * @var GeneratorListenerInterface
     */
    private $eventDispatcher;

    /**
     * @var NamingStrategyInterface
     */
    private $namingStrategy;
    /**
     * @var ConfigurationInterface
     */
    private $configuration;

    /**
     * Constructor.
     *
     * @param ConfigurationInterface $configuration
     * @param TDBMSchemaAnalyzer $tdbmSchemaAnalyzer
     */
    public function __construct(ConfigurationInterface $configuration, TDBMSchemaAnalyzer $tdbmSchemaAnalyzer)
    {
        $this->configuration = $configuration;
        $this->schema = $tdbmSchemaAnalyzer->getSchema();
        $this->tdbmSchemaAnalyzer = $tdbmSchemaAnalyzer;
        $this->namingStrategy = $configuration->getNamingStrategy();
        $this->eventDispatcher = $configuration->getGeneratorEventDispatcher();
    }

    /**
     * Generates all the daos and beans.
     *
     * @throws TDBMException
     */
    public function generateAllDaosAndBeans(): void
    {
        // TODO: check that no class name ends with "Base". Otherwise, there will be name clash.

        $tableList = $this->schema->getTables();

        // Remove all beans and daos from junction tables
        $junctionTables = $this->configuration->getSchemaAnalyzer()->detectJunctionTables(true);
        $junctionTableNames = array_map(function (Table $table) {
            return $table->getName();
        }, $junctionTables);

        $tableList = array_filter($tableList, function (Table $table) use ($junctionTableNames) {
            return !in_array($table->getName(), $junctionTableNames);
        });

        $beanDescriptors = [];

        foreach ($tableList as $table) {
            $beanDescriptors[] = $this->generateDaoAndBean($table);
        }


        $this->generateFactory($tableList);

        // Let's call the list of listeners
        $this->eventDispatcher->onGenerate($this->configuration, $beanDescriptors);
    }

    /**
     * Generates in one method call the daos and the beans for one table.
     *
     * @param Table $table
     *
     * @return BeanDescriptor
     * @throws TDBMException
     */
    private function generateDaoAndBean(Table $table) : BeanDescriptor
    {
        $tableName = $table->getName();
        $daoName = $this->namingStrategy->getDaoClassName($tableName);
        $beanName = $this->namingStrategy->getBeanClassName($tableName);
        $baseBeanName = $this->namingStrategy->getBaseBeanClassName($tableName);
        $baseDaoName = $this->namingStrategy->getBaseDaoClassName($tableName);

        $beanDescriptor = new BeanDescriptor($table, $this->configuration->getBeanNamespace(), $this->configuration->getBeanNamespace().'\\Generated', $this->configuration->getSchemaAnalyzer(), $this->schema, $this->tdbmSchemaAnalyzer, $this->namingStrategy);
        $this->generateBean($beanDescriptor, $beanName, $baseBeanName, $table);
        $this->generateDao($beanDescriptor, $daoName, $baseDaoName, $beanName, $table);
        return $beanDescriptor;
    }

    /**
     * Writes the PHP bean file with all getters and setters from the table passed in parameter.
     *
     * @param BeanDescriptor  $beanDescriptor
     * @param string          $className       The name of the class
     * @param string          $baseClassName   The name of the base class which will be extended (name only, no directory)
     * @param Table           $table           The table
     *
     * @throws TDBMException
     */
    public function generateBean(BeanDescriptor $beanDescriptor, $className, $baseClassName, Table $table)
    {
        $beannamespace = $this->configuration->getBeanNamespace();
        $str = $beanDescriptor->generatePhpCode();

        $possibleBaseFileName = $this->configuration->getPathFinder()->getPath($beannamespace.'\\Generated\\'.$baseClassName)->getPathname();

        $this->dumpFile($possibleBaseFileName, $str);

        $possibleFileName = $this->configuration->getPathFinder()->getPath($beannamespace.'\\'.$className)->getPathname();

        if (!file_exists($possibleFileName)) {
            $tableName = $table->getName();
            $str = "<?php
/*
 * This file has been automatically generated by TDBM.
 * You can edit this file as it will not be overwritten.
 */

declare(strict_types=1);

namespace {$beannamespace};

use {$beannamespace}\\Generated\\{$baseClassName};

/**
 * The $className class maps the '$tableName' table in database.
 */
class $className extends $baseClassName
{
}
";

            $this->dumpFile($possibleFileName, $str);
        }
    }

    /**
     * Tries to find a @defaultSort annotation in one of the columns.
     *
     * @param Table $table
     *
     * @return array First item: column name, Second item: column order (asc/desc)
     */
    private function getDefaultSortColumnFromAnnotation(Table $table)
    {
        $defaultSort = null;
        $defaultSortDirection = null;
        foreach ($table->getColumns() as $column) {
            $comments = $column->getComment();
            $matches = [];
            if ($comments !== null && preg_match('/@defaultSort(\((desc|asc)\))*/', $comments, $matches) != 0) {
                $defaultSort = $column->getName();
                if (count($matches) === 3) {
                    $defaultSortDirection = $matches[2];
                } else {
                    $defaultSortDirection = 'ASC';
                }
            }
        }

        return [$defaultSort, $defaultSortDirection];
    }

    /**
     * Writes the PHP bean DAO with simple functions to create/get/save objects.
     *
     * @param BeanDescriptor  $beanDescriptor
     * @param string          $className       The name of the class
     * @param string          $baseClassName
     * @param string          $beanClassName
     * @param Table           $table
     *
     * @throws TDBMException
     */
    private function generateDao(BeanDescriptor $beanDescriptor, string $className, string $baseClassName, string $beanClassName, Table $table)
    {
        $daonamespace = $this->configuration->getDaoNamespace();
        $beannamespace = $this->configuration->getBeanNamespace();
        $tableName = $table->getName();
        $primaryKeyColumns = self::getPrimaryKeyColumnsOrFail($table);

        list($defaultSort, $defaultSortDirection) = $this->getDefaultSortColumnFromAnnotation($table);

        $beanClassWithoutNameSpace = $beanClassName;
        $beanClassName = $beannamespace.'\\'.$beanClassName;

        list($usedBeans, $findByDaoCode) = $beanDescriptor->generateFindByDaoCode($beannamespace, $beanClassWithoutNameSpace);

        $usedBeans[] = $beanClassName;
        // Let's suppress duplicates in used beans (if any)
        $usedBeans = array_flip(array_flip($usedBeans));
        $useStatements = array_map(function ($usedBean) {
            return "use $usedBean;\n";
        }, $usedBeans);

        $str = "<?php
/*
 * This file has been automatically generated by TDBM.
 * DO NOT edit this file, as it might be overwritten.
 * If you need to perform changes, edit the $className class instead!
 */

declare(strict_types=1);

namespace {$daonamespace}\\Generated;

use TheCodingMachine\\TDBM\\TDBMService;
use TheCodingMachine\\TDBM\\ResultIterator;
".implode('', $useStatements)."
/**
 * The $baseClassName class will maintain the persistence of $beanClassWithoutNameSpace class into the $tableName table.
 *
 */
class $baseClassName
{

    /**
     * @var TDBMService
     */
    protected \$tdbmService;

    /**
     * The default sort column.
     *
     * @var string
     */
    private \$defaultSort = ".($defaultSort ? "'$defaultSort'" : 'null').';

    /**
     * The default sort direction.
     *
     * @var string
     */
    private $defaultDirection = '.($defaultSort && $defaultSortDirection ? "'$defaultSortDirection'" : "'asc'").";

    /**
     * Sets the TDBM service used by this DAO.
     *
     * @param TDBMService \$tdbmService
     */
    public function __construct(TDBMService \$tdbmService)
    {
        \$this->tdbmService = \$tdbmService;
    }

    /**
     * Persist the $beanClassWithoutNameSpace instance.
     *
     * @param $beanClassWithoutNameSpace \$obj The bean to save.
     */
    public function save($beanClassWithoutNameSpace \$obj)
    {
        \$this->tdbmService->save(\$obj);
    }

    /**
     * Get all $beanClassWithoutNameSpace records.
     *
     * @return {$beanClassWithoutNameSpace}[]|ResultIterator
     */
    public function findAll() : iterable
    {
        if (\$this->defaultSort) {
            \$orderBy = '$tableName.'.\$this->defaultSort.' '.\$this->defaultDirection;
        } else {
            \$orderBy = null;
        }
        return \$this->tdbmService->findObjects('$tableName', null, [], \$orderBy);
    }
    ";

        if (count($primaryKeyColumns) === 1) {
            $primaryKeyColumn = $primaryKeyColumns[0];
            $primaryKeyPhpType = self::dbalTypeToPhpType($table->getColumn($primaryKeyColumn)->getType());
            $str .= "
    /**
     * Get $beanClassWithoutNameSpace specified by its ID (its primary key)
     * If the primary key does not exist, an exception is thrown.
     *
     * @param $primaryKeyPhpType \$id
     * @param bool \$lazyLoading If set to true, the object will not be loaded right away. Instead, it will be loaded when you first try to access a method of the object.
     * @return $beanClassWithoutNameSpace
     * @throws TDBMException
     */
    public function getById($primaryKeyPhpType \$id, \$lazyLoading = false) : $beanClassWithoutNameSpace
    {
        return \$this->tdbmService->findObjectByPk('$tableName', ['$primaryKeyColumn' => \$id], [], \$lazyLoading);
    }
    ";
        }
        $str .= "
    /**
     * Deletes the $beanClassWithoutNameSpace passed in parameter.
     *
     * @param $beanClassWithoutNameSpace \$obj object to delete
     * @param bool \$cascade if true, it will delete all object linked to \$obj
     */
    public function delete($beanClassWithoutNameSpace \$obj, \$cascade = false) : void
    {
        if (\$cascade === true) {
            \$this->tdbmService->deleteCascade(\$obj);
        } else {
            \$this->tdbmService->delete(\$obj);
        }
    }


    /**
     * Get a list of $beanClassWithoutNameSpace specified by its filters.
     *
     * @param mixed \$filter The filter bag (see TDBMService::findObjects for complete description)
     * @param array \$parameters The parameters associated with the filter
     * @param mixed \$orderBy The order string
     * @param array \$additionalTablesFetch A list of additional tables to fetch (for performance improvement)
     * @param int \$mode Either TDBMService::MODE_ARRAY or TDBMService::MODE_CURSOR (for large datasets). Defaults to TDBMService::MODE_ARRAY.
     * @return {$beanClassWithoutNameSpace}[]|ResultIterator
     */
    protected function find(\$filter = null, array \$parameters = [], \$orderBy=null, array \$additionalTablesFetch = [], \$mode = null) : iterable
    {
        if (\$this->defaultSort && \$orderBy == null) {
            \$orderBy = '$tableName.'.\$this->defaultSort.' '.\$this->defaultDirection;
        }
        return \$this->tdbmService->findObjects('$tableName', \$filter, \$parameters, \$orderBy, \$additionalTablesFetch, \$mode);
    }

    /**
     * Get a list of $beanClassWithoutNameSpace specified by its filters.
     * Unlike the `find` method that guesses the FROM part of the statement, here you can pass the \$from part.
     *
     * You should not put an alias on the main table name. So your \$from variable should look like:
     *
     *   \"$tableName JOIN ... ON ...\"
     *
     * @param string \$from The sql from statement
     * @param mixed \$filter The filter bag (see TDBMService::findObjects for complete description)
     * @param array \$parameters The parameters associated with the filter
     * @param mixed \$orderBy The order string
     * @param int \$mode Either TDBMService::MODE_ARRAY or TDBMService::MODE_CURSOR (for large datasets). Defaults to TDBMService::MODE_ARRAY.
     * @return {$beanClassWithoutNameSpace}[]|ResultIterator
     */
    protected function findFromSql(\$from, \$filter = null, array \$parameters = [], \$orderBy = null, \$mode = null) : iterable
    {
        if (\$this->defaultSort && \$orderBy == null) {
            \$orderBy = '$tableName.'.\$this->defaultSort.' '.\$this->defaultDirection;
        }
        return \$this->tdbmService->findObjectsFromSql('$tableName', \$from, \$filter, \$parameters, \$orderBy, \$mode);
    }

    /**
     * Get a list of $beanClassWithoutNameSpace from a SQL query.
     * Unlike the `find` and `findFromSql` methods, here you can pass the whole \$sql query.
     *
     * You should not put an alias on the main table name, and select its columns using `*`. So the SELECT part of you \$sql should look like:
     *
     *   \"SELECT $tableName.* FROM ...\"
     *
     * @param string \$sql The sql query
     * @param array \$parameters The parameters associated with the filter
     * @param string \$countSql The count sql query (automatically computed if not provided)
     * @param int \$mode Either TDBMService::MODE_ARRAY or TDBMService::MODE_CURSOR (for large datasets). Defaults to TDBMService::MODE_ARRAY.
     * @return {$beanClassWithoutNameSpace}[]|ResultIterator
     */
    protected function findFromRawSql(\$sql, array \$parameters = [], \$countSql = null, \$mode = null) : iterable
    {
        return \$this->tdbmService->findObjectsFromRawSql('$tableName', \$sql, \$parameters, \$mode, null, \$countSql);
    }

    /**
     * Get a single $beanClassWithoutNameSpace specified by its filters.
     *
     * @param mixed \$filter The filter bag (see TDBMService::findObjects for complete description)
     * @param array \$parameters The parameters associated with the filter
     * @param array \$additionalTablesFetch A list of additional tables to fetch (for performance improvement)
     * @return $beanClassWithoutNameSpace|null
     */
    protected function findOne(\$filter = null, array \$parameters = [], array \$additionalTablesFetch = []) : ?$beanClassWithoutNameSpace
    {
        return \$this->tdbmService->findObject('$tableName', \$filter, \$parameters, \$additionalTablesFetch);
    }

    /**
     * Get a single $beanClassWithoutNameSpace specified by its filters.
     * Unlike the `find` method that guesses the FROM part of the statement, here you can pass the \$from part.
     *
     * You should not put an alias on the main table name. So your \$from variable should look like:
     *
     *   \"$tableName JOIN ... ON ...\"
     *
     * @param string \$from The sql from statement
     * @param mixed \$filter The filter bag (see TDBMService::findObjects for complete description)
     * @param array \$parameters The parameters associated with the filter
     * @return $beanClassWithoutNameSpace|null
     */
    protected function findOneFromSql(\$from, \$filter = null, array \$parameters = []) : ?$beanClassWithoutNameSpace
    {
        return \$this->tdbmService->findObjectFromSql('$tableName', \$from, \$filter, \$parameters);
    }

    /**
     * Sets the default column for default sorting.
     *
     * @param string \$defaultSort
     */
    public function setDefaultSort(string \$defaultSort) : void
    {
        \$this->defaultSort = \$defaultSort;
    }
";

        $str .= $findByDaoCode;
        $str .= '}
';

        $possibleBaseFileName = $this->configuration->getPathFinder()->getPath($daonamespace.'\\Generated\\'.$baseClassName)->getPathname();

        $this->dumpFile($possibleBaseFileName, $str);

        $possibleFileName = $this->configuration->getPathFinder()->getPath($daonamespace.'\\'.$className)->getPathname();

        // Now, let's generate the "editable" class
        if (!file_exists($possibleFileName)) {
            $str = "<?php
/*
 * This file has been automatically generated by TDBM.
 * You can edit this file as it will not be overwritten.
 */

declare(strict_types=1);

namespace {$daonamespace};

use {$daonamespace}\\Generated\\{$baseClassName};

/**
 * The $className class will maintain the persistence of $beanClassWithoutNameSpace class into the $tableName table.
 */
class $className extends $baseClassName
{
}
";
            $this->dumpFile($possibleFileName, $str);
        }
    }

    /**
     * Generates the factory bean.
     *
     * @param Table[] $tableList
     * @throws TDBMException
     */
    private function generateFactory(array $tableList) : void
    {
        $daoNamespace = $this->configuration->getDaoNamespace();
        $daoFactoryClassName = $this->namingStrategy->getDaoFactoryClassName();

        // For each table, let's write a property.

        $str = "<?php
declare(strict_types=1);

/*
 * This file has been automatically generated by TDBM.
 * DO NOT edit this file, as it might be overwritten.
 */

namespace {$daoNamespace}\\Generated;

";
        foreach ($tableList as $table) {
            $tableName = $table->getName();
            $daoClassName = $this->namingStrategy->getDaoClassName($tableName);
            $str .= "use {$daoNamespace}\\".$daoClassName.";\n";
        }

        $str .= "
/**
 * The $daoFactoryClassName provides an easy access to all DAOs generated by TDBM.
 *
 */
class $daoFactoryClassName
{
";

        foreach ($tableList as $table) {
            $tableName = $table->getName();
            $daoClassName = $this->namingStrategy->getDaoClassName($tableName);
            $daoInstanceName = self::toVariableName($daoClassName);

            $str .= '    /**
     * @var '.$daoClassName.'
     */
    private $'.$daoInstanceName.';

    /**
     * Returns an instance of the '.$daoClassName.' class.
     *
     * @return '.$daoClassName.'
     */
    public function get'.$daoClassName.'() : '.$daoClassName.'
    {
        return $this->'.$daoInstanceName.';
    }

    /**
     * Sets the instance of the '.$daoClassName.' class that will be returned by the factory getter.
     *
     * @param '.$daoClassName.' $'.$daoInstanceName.'
     */
    public function set'.$daoClassName.'('.$daoClassName.' $'.$daoInstanceName.') : void
    {
        $this->'.$daoInstanceName.' = $'.$daoInstanceName.';
    }';
        }

        $str .= '
}
';

        $possibleFileName = $this->configuration->getPathFinder()->getPath($daoNamespace.'\\Generated\\'.$daoFactoryClassName)->getPathname();

        $this->dumpFile($possibleFileName, $str);
    }

    /**
     * Transforms a string to camelCase (except the first letter will be uppercase too).
     * Underscores and spaces are removed and the first letter after the underscore is uppercased.
     * Quoting is removed if present.
     *
     * @param string $str
     *
     * @return string
     */
    public static function toCamelCase($str) : string
    {
        $str = str_replace(array('`', '"', '[', ']'), '', $str);

        $str = strtoupper(substr($str, 0, 1)).substr($str, 1);
        while (true) {
            if (strpos($str, '_') === false && strpos($str, ' ') === false) {
                break;
            }

            $pos = strpos($str, '_');
            if ($pos === false) {
                $pos = strpos($str, ' ');
            }
            $before = substr($str, 0, $pos);
            $after = substr($str, $pos + 1);
            $str = $before.strtoupper(substr($after, 0, 1)).substr($after, 1);
        }

        return $str;
    }

    /**
     * Tries to put string to the singular form (if it is plural).
     * We assume the table names are in english.
     *
     * @param string $str
     *
     * @return string
     */
    public static function toSingular($str)
    {
        return Inflector::singularize($str);
    }

    /**
     * Put the first letter of the string in lower case.
     * Very useful to transform a class name into a variable name.
     *
     * @param string $str
     *
     * @return string
     */
    public static function toVariableName($str)
    {
        return strtolower(substr($str, 0, 1)).substr($str, 1);
    }

    /**
     * Ensures the file passed in parameter can be written in its directory.
     *
     * @param string $fileName
     *
     * @throws TDBMException
     */
    private function ensureDirectoryExist(string $fileName)
    {
        $dirName = dirname($fileName);
        if (!file_exists($dirName)) {
            $old = umask(0);
            $result = mkdir($dirName, 0775, true);
            umask($old);
            if ($result === false) {
                throw new TDBMException("Unable to create directory: '".$dirName."'.");
            }
        }
    }

    private function dumpFile(string $fileName, string $content) : void
    {
        $this->ensureDirectoryExist($fileName);
        $fileSystem = new Filesystem();
        $fileSystem->dumpFile($fileName, $content);
        @chmod($fileName, 0664);
    }

    /**
     * Transforms a DBAL type into a PHP type (for PHPDoc purpose).
     *
     * @param Type $type The DBAL type
     *
     * @return string The PHP type
     */
    public static function dbalTypeToPhpType(Type $type) : string
    {
        $map = [
            Type::TARRAY => 'array',
            Type::SIMPLE_ARRAY => 'array',
            'json' => 'array',  // 'json' is supported from Doctrine DBAL 2.6 only.
            Type::JSON_ARRAY => 'array',
            Type::BIGINT => 'string',
            Type::BOOLEAN => 'bool',
            Type::DATETIME_IMMUTABLE => '\DateTimeImmutable',
            Type::DATETIMETZ_IMMUTABLE => '\DateTimeImmutable',
            Type::DATE_IMMUTABLE => '\DateTimeImmutable',
            Type::TIME_IMMUTABLE => '\DateTimeImmutable',
            Type::DECIMAL => 'string',
            Type::INTEGER => 'int',
            Type::OBJECT => 'string',
            Type::SMALLINT => 'int',
            Type::STRING => 'string',
            Type::TEXT => 'string',
            Type::BINARY => 'resource',
            Type::BLOB => 'resource',
            Type::FLOAT => 'float',
            Type::GUID => 'string',
        ];

        return isset($map[$type->getName()]) ? $map[$type->getName()] : $type->getName();
    }

    /**
     * @param Table $table
     * @return string[]
     * @throws TDBMException
     */
    public static function getPrimaryKeyColumnsOrFail(Table $table): array {
        if ($table->getPrimaryKey() === null) {
            // Security check: a table MUST have a primary key
            throw new TDBMException(sprintf('Table "%s" does not have any primary key', $table->getName()));
        }
        return $table->getPrimaryKey()->getUnquotedColumns();
    }
}
